#lang racket
(require "program.rkt")
(provide (all-defined-out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;synchk;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;function takes as input an program and returns true if and only if the program can be generated by the above grammar
;;input: program
;;output: #t or #f
;;example: (synchk '(var ((z 3)) (+ z x))): #t
;;example: (synchk '(((z 3)) (+ z x))): #f
(define (synchk program)
  (Expr? program) ;;use function Expr? to check if the program is a expr
  )

;;function to check if the input is a valid expr
;;input: program
;;output: #t or #f
;;example: (Expr? '(var ((z 3)) (+ z x))): #t
;;example: (Expr? '(((z 3)) (+ z x))): #f
(define (Expr? program)
  (or (number? program) (symbol? program) (OpExpr? program)) ;;return true iff it is any of number, symbol or OpExpr.
  )
;;function to check if the input is a valid OpExpr
;;input: Expr
;;output: #t or #f
;;example: (OpExpr? '(var ((z 3)) (+ z x))): #t
;;example: (OpExpr? '(((z 3)) (+ z x))): #f
(define (OpExpr? expr)
  (or (ArithExpr? expr) (CondExpr? expr) (VarExpr? expr)) ;;return true iff it is any of ArithExpr, CondExpr or VarExpr.
  )
;;function to check if the input is a valid ArithExpr
;;input: OpExpr
;;output: #t or #f
;;example: (ArithExpr? '(+ 3 2)): #t
;;example: (ArithExpr? '(/ 2)): #f
(define (ArithExpr? OpExpr)
  (and (equal? (length OpExpr) 3) (Op? (car OpExpr)) (Expr? (second OpExpr)) (Expr? (third OpExpr))) ;;return true iff its length is 3 and has form (Op Expr Expr)
  )
;;function to check if the input is a Op
;;input: OpExpr
;;output: #t or #f
;;example: (Op? '+): #t
;;example: (Op? '(*)): #f
(define (Op? OpExpr)
  (or (equal? OpExpr '+) (equal? OpExpr '-) (equal? OpExpr '*) (equal? OpExpr '/)) ;;return true iff it's any of + - * /
  )
;;function to check if the input is a OpExpr
;;input: OpExpr
;;output: #t or #f
;;example: (CondExpr? (list '(or (gt 3 3) (lt 4 5)) 3 4)): #t
;;example: (CondExpr? (list 'and '(lt 3 4))): #f
(define (CondExpr? OpExpr)
  (and (equal? (length OpExpr) 3) (CCond? (car OpExpr)) (Expr? (second OpExpr)) (Expr? (third OpExpr))) ;;return true iff its length is 3 and has form (CCond Expr Expr)
  )
;;function to check if the input is a CCond
;;input: condExpr
;;output: #t or #f
;;example: (CCond? '(or (gt 3 3) (lt 4 5))): #t
;;example: (CCond? (list '(or (gt 3 3) (lt 4 5)) 3)): #f
(define (CCond? condExpr)
  (if (not (list? condExpr))
      false ;;return false if the input is not a list
      (if (BCond? condExpr) ;;check if the input is a BCond
          true
          (if (equal? (length condExpr) 2) ;;if it's not a BCond, check length
              (and (equal? (first condExpr) 'not) (CCond? (second condExpr))) ;;if its length is 2, return true iff its form is (not CCond) by recursion
              (if (not (equal? (length condExpr) 3)) ;;otherwise
                  false ;; return false if the length is not 2 or 3
                  (or  (and (equal? (first condExpr) 'or) (CCond? (second condExpr)) (CCond? (third condExpr)) ) (and (equal? (first condExpr) 'and) (CCond? (second condExpr)) (CCond? (third condExpr))))
                  ;; if its length is 3, return true iff its form is (or CCond CCond) | (and CCond CCond) by recursion
                  )
              )
          )
      )
  )
;;function to check if the input is a BCond
;;input: CCond
;;output: #t or #f
;;example: (BCond? '(gt 3 3)): #t
;;example: (BCond? '(greaterthan 3 4 3)): #f
(define (BCond? CCond)
   (if (not (equal? (length CCond) 3)) ;; its length has to be 3
       false ;;return false if its length is not 3
       (if (not (or (equal? (first CCond) 'gt) (equal? (first CCond) 'lt) (equal? (first CCond) 'eq) )) ;;check its first element
           false ;;return false iff its first element is not any of gt lt eq
           (and (Expr? (second CCond)) (Expr? (third CCond))) ;; do recursion and return true ifd its form is  (gt Expr Expr) | (lt Expr Expr) | (eq Expr Expr)
           )
       )
  )
;;function to check if the input is a VarExpr
;;input: expr
;;output: #t or #f
;;example: (VarExpr? (list 'var '((x 3) (y 2) (z 6)) '3)): #t
;;example: (VarExpr? (list 'let '((x 3) (y 2) (z 6)) '3)): #f
(define (VarExpr? expr)
  ;; return true iff its length is 3 and form is  (var VarAssign Expr)
  (or (and (equal? (length expr) 3) (equal? (first expr) 'var) (VarAssign? (second expr)) (Expr? (third expr))) (and (equal? (length expr) 2) (VarAssign? expr)))
  )
;;function to check if the input is a VarAssign
;;input: VarExpr
;;output: #t or #f
;;example: (VarAssign?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssign?  '()): #f
(define (VarAssign? expr)
  (if (null? expr)
      false ;; return false if the input is null
      (VarAssignSeq? expr) ;;otherwise, check if it's a VarAssignSeq
      )
  )
;;function to check if the input is a VarAssignSeq
;;input: VarAssign
;;output: #t or #f
;;example: (VarAssignSeq?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssignSeq?  '(x 3 2)): #f
(define (VarAssignSeq? expr)
  (if (not (list? expr)) 
      false ;;return false if it's not a list
      (if (null? expr) ;;otherwise
          true ;;return true if it's null
          (if (not (list? (car expr))) ;;if the first element of it is not a list
              (and (equal? (length expr) 2) (symbol? (first (car expr))) (Expr? (second (car expr)))) ;;return true iff its length is 2 and form is  (Variable Expr)
              (and (equal? (length (first expr)) 2)(symbol? (first (first expr))) (Expr? (second (first expr))) (VarAssignSeq? (cdr expr)))
              ;;otherwise, do recursion and return true iff its form is  (Variable Expr) VarAssignSeq
              )
          )
      )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;eval;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;function takes as input a program, an environment and returns the semantics of the expression.
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;example: (eval  '(+ x y) '((x 3) (y 4) (z 5))): 7
;;example: (eval  '(+ x y z) '((x 3) (y 4) (z 5))): '(Cannot Evaluate)
(define (eval program environment)
  (if (synchk program) ;;check if the input program is valid
      (Expr program environment) ;; evaluate program with environment using function Expr
      '(Cannot Evaluate) ;; return '(Cannot Evaluate) if the program is not valid
      )
  )
;;function to evaluate Expr with enviornment
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (Expr  '(+ x y) '((x 3) (y 4) (z 5))): 7
;;example: (Expr  '(+ x y z) '((x 3) (y 4) (z 5))): '(Cannot Evaluate)
(define (Expr p e)
  (cond
    [(number? p) p] ;;if p is a number, return p
    [(symbol? p) (Variable p e)] ;;if p is a symbol, evaluate p and e with function Variable
    [(OpExpr? p) (OpExpr p e)] ;;if p is a OpExpr,  evaluate p and e with function OpExpr
    [else '(Cannot Evaluate)] ;;this part is useless just for small function test
    )
  )
;;function to evaluate Variable with enviornment
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (Variable  'x '((x 3) (y 4) (z 5))): 3
;;example: (Variable  'x '()): '(Cannot Evaluate)
(define (Variable p e)
  (if (null? e)
      '(Cannot Evaluate) ;; return '(Cannot Evaluate) if enviornment is null
      (if (equal? (first(first e)) p) ;;check if the first element in first part of the enviornment equals to p
          (second(car e)) ;;return the second element in first part of the enviornment as a output
          (Variable p (cdr e)) ;;do recursion on enviornment to check if the second part contains p
          )
      )
  )
;;function to evaluate OpExpr with enviornment
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (OpExpr  '(+ x y) '((x 3) (y 4) (z 5))): 7
;;example: (OpExpr  '(+ x y z) '((x 3) (y 4) (z 5))): '(Cannot Evaluate)
(define (OpExpr p e)
  (cond
    [(ArithExpr? p) (ArithExpr p e)] ;;if p is a ArrithExpr, use function ArithExpr to evalute p with e
    [(CondExpr? p) (CondExpr p e)] ;;if p is a CondExpr, use function CondExpr to evalute p with e
    [(VarExpr? p) (VarExpr p e)] ;;if p is a VarExpr, use function VarExpr to evalute p with e
    [else '(Cannot Evaluate)] ;;if it's not any of the above, return '(Cannot Evaluate) (this part is useless since I've checked if it is a OpExpr. Just for small func test)
    )
  )
;;function to evaluate OpExpr with enviornment
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (ArithExpr  '(+ x 1) '((x 3))): 4
;;example: (ArithExpr  '(+ x undefined) '((x 3))): '(Cannot Evaluate)
(define (ArithExpr p e)
  (cond
    ;;if any of the second and thrid elements is free element, return '(Cannot Evaluate)
    [(or (equal? (Expr (second p) e) '(Cannot Evaluate)) (equal? (Expr (third p) e) '(Cannot Evaluate)) ) '(Cannot Evaluate)]
    [(equal? (car p) '+) (+ (Expr (second p) e) (Expr (third p) e))] ;;if the first element is '+, do second element + thrid element with e
    [(equal? (car p) '-) (- (Expr (second p) e) (Expr (third p) e))] ;;if the first element is '-, do second element - thrid element with e
    [(equal? (car p) '*) (* (Expr (second p) e) (Expr (third p) e))] ;;if the first element is '*, do second element * thrid element with e
    [(equal? (car p) '/) (/ (Expr (second p) e) (Expr (third p) e))] ;;if the first element is '/, do second element / thrid element with e
    )
  )
;;function to evaluate CondExpr with enviornment
;;input: program & enviornment
;;output: the semantics of the expression or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (CondExpr  (list '(< x 1) 0 1) '((x 3)) ): 0
;;example: (CondExpr  (list '(> x 1) 0 1) '((x 3)) ): 1
;;example: (CondExpr  (list '(> x 1) 'undefine 1) '((x 3)) ): '(Cannot Evaluate)
(define (CondExpr p e)
  (if (or (equal? (Expr (second p) e) '(Cannot Evaluate)) (equal? (Expr (third p) e) '(Cannot Evaluate)) )
      '(Cannot Evaluate) ;;if any of the second and thrid elements is free element, return '(Cannot Evaluate)
      (if (CCond (car p) e) ;;check condition using function CCond
          (Expr (second p) e) ;;return the second element if true
          (Expr (third p) e) ;;otherwise, return the third element
          )
      )
  )
;;function to evaluate CCond with enviornment
;;input: program & enviornment
;;output: #t or #f or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (CCond '(gt x 1) '((x 3))): #t
;;example: (CCond '(lt x 1) '((x 3))): #f
;;example: (CCond '(> x 1) '((x 3))): '(Cannot Evaluate)
(define (CCond p e)
  (cond
    [(BCond? p) (BCond p e)] ;; if p is a BCond, evaluate p e with function BCond
    [(equal? (car p) 'and) (and (CCond (cadr p) e) (CCond (caddr p) e))] ;;if the first element is 'and, return true if both second element and third element are true
    [(equal? (car p) 'or) (or (CCond (cadr p) e) (CCond (caddr p) e))] ;;if the first element is 'or, return true if either second element or third element is true
    [(equal? (car p) 'not) (not (CCond (cadr p) e))] ;;if the first element is 'not, return true if the second element is false
    [else '(Cannot Evaluate)] ;;else return '(Cannot Evaluate) (this part is useless since I've checked if p is BCond)
    )
  )
;;function to evaluate BCond with enviornment
;;input: program & enviornment
;;output: #t or #f or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (BCond '(gt x 1) '((x 3))): #t
;;example: (BCond '(lt x 1) '((x 3))): #f
;;example: (BCond '(> x 1) '((x 3))): '(Cannot Evaluate)
(define (BCond p e)
  (cond
    ;;if any of the second and thrid elements is free element, return '(Cannot Evaluate)
    [(or (equal? (Expr (cadr p) e) '(Cannot Evaluate)) (equal? (Expr (caddr p) e) '(Cannot Evaluate)) ) '(Cannot Evaluate)]
    [(equal? (car p) 'gt) (> (Expr (cadr p) e) (Expr (caddr p) e))] ;;return true if cadr p > caddr p
    [(equal? (car p) 'lt) (< (Expr (cadr p) e) (Expr (caddr p) e))] ;;return true if cadr p < caddr p
    [(equal? (car p) 'eq) (= (Expr (cadr p) e) (Expr (caddr p) e))] ;;return true if cadr p = caddr p
    [else '(Cannot Evaluate)] ;;else return '(Cannot Evaluate)
    )
  )
;;function to evaluate VarExpr with enviornment
;;input: program & enviornment
;;output: evaluate the third element with a new enviornment or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (VarExpr '(var ((z 3)) (+ z x)) '((x 3))): 6
;;example: (VarExpr '(var ((z undefine)) (+ z x)) '((x 3))): '(Cannot Evaluate)
(define (VarExpr p e)
  (if (not (checkVarAssign (second p) e)) ;; call helper function to check if the program is valid
      '(Cannot Evaluate) ;;if the VarAssign contains free element, return '(Cannot Evaluate)
      (Expr (third p) (VarAssign (second p) e)) ;; evaluate the third element with a new enviornment returned by function VarAssign
      )
  )
;;helper function to check if the VarAssign contains free elements
;;input: program & enviornment
;;output: #t or #f or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (checkVarAssign '((z x)) '((x 3))): #t
;;example: (checkVarAssign '((z q)) '((x 3))): #f
(define (checkVarAssign p e)
  (if (not (VarAssign? p)) 
      false ;;return false if it's not evne a VarAssign
      (if (null? (cdr p)) ;;if length is 1
          (if (equal? (Expr (second (car p)) e) '(Cannot Evaluate))
              false ;;return false if first element is free element
              true ;;return true otherwise
              )
          (and (not (equal? (Expr (second(car p)) e) '(Cannot Evaluate))) (checkVarAssign (cdr p) e)) ;;if length is greater than 1, do recursion to check all parts in the list
          )
      )
  )
;;function to evaluate VarAssign with enviornment
;;input: program & enviornment
;;output: new enviornment or '(Cannot Evaluate)
;;p: program; e: enviornment
;;example: (VarAssign '((z 3)) '((x 3))): '((z 3) (x 3))
;;example: (VarAssign '() '((x 3))): '((x 3))
(define (VarAssign p e)
  (if (null? p)
      e ;;return null if p is null
      (if (null? (cdr p)) ;;if length is 1
          (VarAssignSeq (car p) e) ;; return a new enviornment returned by function VarAssignSeq
          (if (not (null? (VarAssignSeq (car p) e))) ;;if function VarAssignSeq doesn't return null
              (append (VarAssign (cdr p) (VarAssignSeq (car p) e)) (list (car (VarAssignSeq (car p) e)))) ;;do recursion on p with function VarAssignSeq (add all them into new Enviornment)
              '() ;;return null is VarAssignSeq returns null
              )
          )
      )
  )
;;function to evaluate VarAssign with enviornment
;;input: program & enviornment
;;output: new element to add to the new enviornment
;;p: program; e: enviornment
;;example: (VarAssignSeq '(z 3) '((x 3))): '((z 3) (x 3))
;;example: (VarAssignSeq '() '((x 3))): '((x 3))
(define (VarAssignSeq p e)
  (if (or (null? p) (equal? (Expr (car(cdr p)) e) '(Cannot Evaluate))) ;;if p is null or first element of second part is free element
      e ;;return the original e without any change
      (cons (list (car p) (Expr (car(cdr p)) e))e) ;;add new enviornment to e and return the new e 
      )
  )
