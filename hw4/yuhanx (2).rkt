#lang racket
(require racket/trace)
(require "program.rkt")
(provide (all-defined-out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;synchk;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;function takes as input an program and returns true if and only if the program can be generated by the above grammar
;;input: program
;;output: #t or #f
;;example: (synchk '(var ((z 3)) (+ z x))): #t
;;example: (synchk '(((z 3)) (+ z x))): #f
(define (synchk program)
  (Expr? program '() ));;use function Expr? to check if the program is a expr

;;function to check if the input is a valid expr
;;input: program
;;output: #t or #f
;;example: (Expr? '(var ((z 3)) (+ z x))): #t
;;example: (Expr? '(((z 3)) (+ z x))): #f
(define (Expr? program function)
  (or (number? program) (symbol? program) (OpExpr? program function) (FExpr? program function) (ApplyF? program function)));;return true iff it is any of number, symbol or OpExpr.

;;function to check if the input is a valid FExpr
;;input: expr & functions(env)
;;output: #t or #f
;;example: (FExpr? (list 'fun '((myfunc (x y)) ((gt x y) 1 0)) 0) '()): #t
;;example: (FExpr? (list 'fun '((myfunc (a b c)))) '()): #f
(define (FExpr? expr function)
  ;;check the length and format                                                    ;; save fname and fomalparams in function                  ;;also do saving here (myfunc (pl) myfunc2 (pl))
  (and (equal? (length expr) 3) (equal? (first expr) 'fun) (FAssign? (second expr) (append function (car (second expr)))) (Expr? (third expr) (append function (car (second expr))) )))

;;function to check if the input is a valid FAssign
;;input: expr & functions(env)
;;output: #t or #f
;;example: (FAssign? '((myfunc (x y)) ((gt x y) 1 0)) '()): #t
;;example: (FAssign? '((myfunc (a b c))) '()): #f
(define (FAssign? expr function)
  ;;check the length and format
  (and (equal? (length expr) 2) (equal? (length (car expr)) 2) (symbol? (caar expr)) (FormalParams? (second (car expr))) (Expr? (second expr) function)))

;;function to check if the input is a valid FormalParams
;;input: expr
;;output: #t or #f
;;example: (FormalParams? '()): #t
;;example: (FormalParams? '(3)): #f
(define (FormalParams? expr)
  ;;check format
  (cond
    [ (not (list? expr)) false]
    [ (null? expr) true]
    [ (FormalParamList? expr) true]
    [ (not (FormalParamList? expr)) false]))

;;function to check if the input is a valid FormalParamList
;;input: expr & functions(env)
;;output: #t or #f
;;example: (FormalParamList? '(x y z)): #t
;;example: (FormalParamList? '(x y 3)): #f
(define (FormalParamList? expr)
  ;;check format
  (if (equal? (length expr) 1)
      (symbol? (car expr))
      (and (symbol? (car expr)) (FormalParamList? (cdr expr)) )))

;;function to check if the input is a valid ApplyF
;;input: expr & functions(env)
;;output: #t or #f
;;example: (ApplyF? (list 'apply (list 'myfunc '())) '(myfunc ())): #t
;;example: (ApplyF? '(apply ((3) '())) '(myfunc ())): #f
(define (ApplyF? expr function)
  ;;check format and check if there is a function with same fname and same length of args(fomalparams) in the function(env)
  (and (equal? (length expr) 2) (equal? (length (second expr)) 2) (equal? (first expr) 'apply) (symbol? (car(second expr))) (Args? (second(second expr)) function) (Match? (second expr) function)))

;;helper function to check if there is a function with same fname and same length of args(fomalparams) in the function(env)
;;input: expr & functions(env)
;;output: #t or #f
;;example: (Match? '(myfunc ()) '(myfunc ())): #t
;;example: (Match? '(myfunc ()) '()): #f
(define (Match? expr function)
  (if (null? function)
      false
      (if (and (equal? (first expr) (first function)) (equal? (length (second expr)) (length (second function)) ))
          true
          (Match? expr (cddr function)))));;recursion on function to check if there is a valid function

;;function to check if the input is a valid Args
;;input: expr & functions(env)
;;output: #t or #f
;;example: (Args? '() '(myfunc ())): #t
;;example: (Args? '((var (x))) '(myfunc ())): #f     
(define (Args? expr function)
  ;;check format
  (cond
    [ (not (list? expr)) false]
    [ (null? expr) true]
    [ (ArgList? expr function) true]
    [ (not (ArgList? expr function)) false]))

;;function to check if the input is a valid ArgList
;;input: expr & functions(env)
;;output: #t or #f
;;example: (ArgList? '(3 2 3 4) '(myfunc ())): #t
;;example: (ArgList? '((var (x))) '(myfunc ())): #f 
(define (ArgList? expr function)
  ;;check format
  (if (equal? (length expr) 1)
      (Expr? (car expr) function)
      (and (Expr? (car expr) function) (ArgList? (cdr expr) function) )))

  

;;function to check if the input is a valid OpExpr
;;input: Expr
;;output: #t or #f
;;example: (OpExpr? '(var ((z 3)) (+ z x))): #t
;;example: (OpExpr? '(((z 3)) (+ z x))): #f
(define (OpExpr? expr function)
  (or (ArithExpr? expr function) (CondExpr? expr function) (VarExpr? expr function)));;return true iff it is any of ArithExpr, CondExpr or VarExpr.

;;function to check if the input is a valid ArithExpr
;;input: OpExpr
;;output: #t or #f
;;example: (ArithExpr? '(+ 3 2)): #t
;;example: (ArithExpr? '(/ 2)): #f
(define (ArithExpr? OpExpr function)
  (and (equal? (length OpExpr) 3) (Op? (car OpExpr)) (Expr? (second OpExpr) function) (Expr? (third OpExpr) function)));;return true iff its length is 3 and has form (Op Expr Expr)
;;function to check if the input is a Op
;;input: OpExpr
;;output: #t or #f
;;example: (Op? '+): #t
;;example: (Op? '(*)): #f
(define (Op? OpExpr)
  (or (equal? OpExpr '+) (equal? OpExpr '-) (equal? OpExpr '*) (equal? OpExpr '/)));;return true iff it's any of + - * /
;;function to check if the input is a OpExpr
;;input: OpExpr
;;output: #t or #f
;;example: (CondExpr? (list '(or (gt 3 3) (lt 4 5)) 3 4)): #t
;;example: (CondExpr? (list 'and '(lt 3 4))): #f
(define (CondExpr? OpExpr function)
  (and (equal? (length OpExpr) 3) (CCond? (car OpExpr) function) (Expr? (second OpExpr) function) (Expr? (third OpExpr) function))) ;;return true iff its length is 3 and has form (CCond Expr Expr)
;;function to check if the input is a CCond
;;input: condExpr
;;output: #t or #f
;;example: (CCond? '(or (gt 3 3) (lt 4 5))): #t
;;example: (CCond? (list '(or (gt 3 3) (lt 4 5)) 3)): #f
(define (CCond? condExpr function)
  (if (not (list? condExpr))
      false ;;return false if the input is not a list
      (if (BCond? condExpr function) ;;check if the input is a BCond
          true
          (if (equal? (length condExpr) 2) ;;if it's not a BCond, check length
              (and (equal? (first condExpr) 'not) (CCond? (second condExpr) function)) ;;if its length is 2, return true iff its form is (not CCond) by recursion
              (if (not (equal? (length condExpr) 3)) ;;otherwise
                  false ;; return false if the length is not 2 or 3
                  (or  (and (equal? (first condExpr) 'or) (CCond? (second condExpr) function) (CCond? (third condExpr) function) ) (and (equal? (first condExpr) 'and) (CCond? (second condExpr) function) (CCond? (third condExpr) function))))))))
                  ;; if its length is 3, return true iff its form is (or CCond CCond) | (and CCond CCond) by recursion
       
;;function to check if the input is a BCond
;;input: CCond
;;output: #t or #f
;;example: (BCond? '(gt 3 3)): #t
;;example: (BCond? '(greaterthan 3 4 3)): #f
(define (BCond? CCond function)
   (if (not (equal? (length CCond) 3)) ;; its length has to be 3
       false ;;return false if its length is not 3
       (if (not (or (equal? (first CCond) 'gt) (equal? (first CCond) 'lt) (equal? (first CCond) 'eq) )) ;;check its first element
           false ;;return false iff its first element is not any of gt lt eq
           (and (Expr? (second CCond) function) (Expr? (third CCond) function))))) ;; do recursion and return true ifd its form is  (gt Expr Expr) | (lt Expr Expr) | (eq Expr Expr)
    
;;function to check if the input is a VarExpr
;;input: expr
;;output: #t or #f
;;example: (VarExpr? (list 'var '((x 3) (y 2) (z 6)) '3)): #t
;;example: (VarExpr? (list 'let '((x 3) (y 2) (z 6)) '3)): #f
(define (VarExpr? expr function)
  ;; return true iff its length is 3 and form is  (var VarAssign Expr)
  (or (and (equal? (length expr) 3) (equal? (first expr) 'var) (VarAssign? (second expr) function) (Expr? (third expr) function)) (and (equal? (length expr) 2) (VarAssign? expr function))))
 
;;function to check if the input is a VarAssign
;;input: VarExpr
;;output: #t or #f
;;example: (VarAssign?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssign?  '()): #f
(define (VarAssign? expr function)
  (if (null? expr)
      false ;; return false if the input is null
      (VarAssignSeq? expr function))) ;;otherwise, check if it's a VarAssignSeq
    
;;function to check if the input is a VarAssignSeq
;;input: VarAssign
;;output: #t or #f
;;example: (VarAssignSeq?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssignSeq?  '(x 3 2)): #f
(define (VarAssignSeq? expr function)
  (if (not (list? expr)) 
      false ;;return false if it's not a list
      (if (null? expr) ;;otherwise
          true ;;return true if it's null
          (if (not (list? (car expr))) ;;if the first element of it is not a list
              (and (equal? (length expr) 2) (not (equal? (car expr) 'apply)) (symbol? (car expr)) (Expr? (second expr) function)) ;;return true iff its length is 2 and form is  (Variable Expr)
              (and (equal? (length (first expr)) 2)(symbol? (first (first expr))) (Expr? (second (first expr)) function) (VarAssignSeq? (cdr expr) function)))))) ;;otherwise, do recursion and return true iff its form is  (Variable Expr) VarAssignSeq


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; eval
;; input: program-expression, environment as list of pairs (variable value and functions)
;; output: a number

(define (eval expr env)
  (cond
    [ (number? expr) expr ]  ;; number
    [ (symbol? expr) (findvalue expr env) ] ;; sigma(x)

    ;; implementation of the semantics of variable expression
    [ (equal? (car expr) 'var) (evalvarassign (cadr expr) (cadr (cdr expr)) env) ]
 
    ;; same as before with the arithmatic operations: environment is added
    [ (arithop (car expr)) (evalarith (car expr) (cadr expr) (cadr (cdr expr)) env) ]

    ;; for FExpr: add function to env
    [ (equal? (car expr) 'fun) (eval (third expr) (cons (second expr) env))]

    ;; for ApplyF1(without scoping rules)
    ;; findMatch function & RenewEnv function & FuncParams function & findMatchF function
    [ (and (equal? (car expr) 'apply) (Scope (FuncParams (car (second expr)) env) (findMatch (car (second expr)) env) )) (eval (findMatch (car (second expr)) env) (RenewEnv (second (second expr)) (FuncParams (car (second expr)) env) (cons (car (findMatchF (car (second expr)) env)) env))  )]
    
    ;; for ApplyF2(with scoping rules for variables inside the functions that are not local and are not function parameters)
    ;; findMatch function & RenewEnv function & FuncParams function
    [ (and (equal? (car expr) 'apply) (not (Scope (FuncParams (car (second expr)) env) (findMatch (car (second expr)) env) ))  ) (eval (findMatch (car (second expr)) env) (StaticEnv (car (second expr)) (RenewEnv (second (second expr)) (FuncParams (car (second expr)) env)  env))  )]

    ;; for CondExpr
    ;; evalcond function
    [ else  (if (evalcond (car expr) env) 
                        (eval (cadr expr) env)
                        (eval (cadr (cdr expr)) env)) ]
    )
  )

;;helper function to check if need scoping rule
;;input: formalParamsList & function expr
;;output: #t or #f
;;example: (Scope '(a b) '(var ((x a) (y b)) (+ x y))) : #t
;;example: (Scope '(f g) '(var ((x a) (y b)) (+ x y))) : #f
(define (Scope FP expr)
  (if (null? FP)
      false
      (or (checkScope (car FP) expr) (checkScope (cdr FP) expr) )))
;;helper function to check if need scoping rule
;;input: formalParam & function expr
;;output: #t or #f
;;example: (checkScope 'a '(var ((x a) (y b)) (+ x y))) : #t
;;example: (checkScope 'f '(var ((x a) (y b)) (+ x y))) : #f
(define (checkScope FP expr)
  (if (null? FP)
      false
      (if (null? expr)
          false
          (if (not (list? expr))
              (equal? FP expr)
              (if (not (list? (car expr)))
                  (if (equal? (car expr) FP)
                      true
                      (checkScope FP (cdr expr)))
                  (or (checkScope FP (car expr)) (checkScope FP (cdr expr))))))))

          
          
  
  
;;function to find Expr in env
;;input: fname & env
;;output: Expr in that function(fname)
;;example: (findMatch 'myfunc '(((myfunc ()) (+ x 1)) (x 3))) : '(+ x 1)
;;example: (findMatch 'myfunc '((x 3) ((myfunc ()) (+ x 1)))) : '(+ x 1)
(define (findMatch fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          (second (car env))
          (findMatch fname (cdr env)))));;recursion on env to check until there is one or null

;;function to find function in env
;;input: fname & env
;;output: the whole env after function with fname
;;example: (findMatchF 'myfunc '(((myfunc ()) (+ x 1)) (x 3))) : '(((myfunc ()) (+ x 1)) (x 3))
;;example: (findMatchF 'myfunc '((x 3) ((myfunc ()) (+ x 1)))) : '(((myfunc ()) (+ x 1)))
(define (findMatchF fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          env
          (findMatchF fname (cdr env)))))

;;function to renew the env
;;input: args & formalParams & env
;;output: a new env with (args formalparams) at the beginning
;;example: (RenewEnv '(1 2) '(a b) '(((myfunc ()) (+ x 1)) (x 3)))  : '((a 1) (b 2) ((myfunc ()) (+ x 1)) (x 3))
;;example: (RenewEnv '(2) '(b) '(((myfunc ()) (+ x 1)) (x 3)))  : '((b 2) ((myfunc ()) (+ x 1)) (x 3))
(define (RenewEnv args formalParams env)
  (if (null? args)
      env
      (cons (list (car formalParams) (eval (car args) env)) (RenewEnv (cdr args) (cdr formalParams) env))))
;;function to get FuncParams of a function in env
;;input: fname & env
;;output: FuncParams of the function with fname
;;example: (FuncParams 'myfunc '((a 1) (b 2) ((myfunc ()) (+ x 1)) (x 3))) : '()
;;example: (FuncParams 'myfunc '((a 1) (b 2) ((myfunc (a b c)) (+ x 1)) (x 3))) : '(a b c)
(define (FuncParams fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          (second (caar env))
          (FuncParams fname (cdr env)))))

;;function to get static scoping env
;;input: fname & env
;;output: new env with static scoping rule
;;example: (StaticEnv 'myfunc '((a 1) (b 2) ((myfunc ()) (+ x 1)) (x 3))) : '(((myfunc ()) (+ x 1)) (x 3))
;;example: (StaticEnv 'myfunc '((a 1) (b 2) ((myfunc ()) (+ x 1)) (x 3) (x 4))) : '(((myfunc ()) (+ x 1)) (x 3) (x 4))
(define (StaticEnv fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          env
          (StaticEnv fname (cdr env)))))

;; input: variable, environment
;; output: value to which the variable is mapped to in the environment
;;         It can be '(Cannot Evaluate) 
(define (findvalue x env)
  (if (equal? (car (car env)) x)
      (cadr (car env))
      (findvalue x (cdr env))))

;; input: list of (variable expression), expr to evaluate, environment
;; output: evaluate expr in some environment
(define (evalvarassign varassigns expr env)
  (if (null? varassigns)  ;; no variable expression pair, 
      (eval expr env)     ;; then just evaluate the expression in the current environment
      ;; else
      ;; recursive call with the suffix of varassigns, with the same expr
      ;; in the environment constructed by cons-ing (variable evaluation of expression)
      ;; to the given environment env.
      (evalvarassign (cdr varassigns)
                     expr
                     (cons (list (car (car varassigns))
                                 (eval (cadr (car varassigns)) env))
                           env))))

;; is op arithmatic operation
(define (arithop op)
  (or (equal? op '+)
      (equal? op '-)
      (equal? op '*)
      (equal? op '\))))

;; input: arithoperator, expr-operand1, expr-operand2, env
;; output: '(Cannot Evaluate) or some number
;; used: myapply 
(define (evalarith op expr1 expr2 env)
 (myapply op (eval expr1 env) (eval  expr2 env)))

;; input: conditions of the form (gt/lt/eq expr1 expr2), (or/and cond1 cond2), (not cond)
;; output: true/false, '(Cannot Evaluate)
;; used: myapply
(define (evalcond condexpr env)
  (cond
    [ (equal? (car condexpr) 'gt)
      (myapply 'gt (eval (cadr condexpr) env) (eval (cadr (cdr condexpr)) env)) ]
    
    [ (equal? (car condexpr) 'lt)
      (myapply 'lt (eval (cadr condexpr) env) (eval (cadr (cdr condexpr)) env)) ]
    
    [ (equal? (car condexpr) 'and)
      (myapply 'and (evalcond (cadr condexpr) env)
               (evalcond (cadr (cdr condexpr)) env)) ]

    [ (equal? (car condexpr) 'eq)
      (myapply 'eq (eval (cadr condexpr) env) (eval (cadr (cdr condexpr)) env)) ]
    
    [ (equal? (car condexpr) 'or)
      (myapply 'or (evalcond (cadr condexpr) env)
               (evalcond (cadr (cdr condexpr)) env)) ]

    [ (equal? (car condexpr) 'not)
      (myapply 'not (evalcond (cadr condexpr) env)
               false) ] ;; dummy
    ))


;; input: some operator, arithmatic or conditional
;;        operand-values for the operator
;; output: '(Cannot Evaluate) or number or boolean 
(define (myapply op val1 val2)
  (cond
    [ (equal? op '+) (+ val1 val2) ]
    [ (equal? op '-) (- val1 val2) ]
    [ (equal? op '*) (* val1 val2) ]
    [ (equal? op 'gt) (> val1 val2) ]
    [ (equal? op 'lt) (< val1 val2) ]
    [ (equal? op 'eq) (equal? val1 val2) ]
    [ (equal? op 'and) (and val1 val2) ]
    [ (equal? op 'or) (or val1 val2) ]
    [ (equal? op 'not) (not val1) ]))