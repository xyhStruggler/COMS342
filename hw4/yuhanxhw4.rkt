#lang racket
(require racket/trace)
(require "program.rkt")
(provide (all-defined-out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;synchk;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;function takes as input an program and returns true if and only if the program can be generated by the above grammar
;;input: program
;;output: #t or #f
;;example: (synchk '(var ((z 3)) (+ z x))): #t
;;example: (synchk '(((z 3)) (+ z x))): #f
(define (synchk program)
  (Expr? program '() ));;use function Expr? to check if the program is a expr

;;function to check if the input is a valid expr
;;input: program
;;output: #t or #f
;;example: (Expr? '(var ((z 3)) (+ z x))): #t
;;example: (Expr? '(((z 3)) (+ z x))): #f
(define (Expr? program function)
  (or (number? program) (symbol? program) (OpExpr? program function) (FExpr? program function) (ApplyF? program function)));;return true iff it is any of number, symbol or OpExpr.
;;
(define (FExpr? expr function)
  (and (equal? (length expr) 3) (equal? (first expr) 'fun) (FAssign? (second expr) (append function (car (second expr)))) (Expr? (third expr) (append function (car (second expr))) )))

(define (FAssign? expr function)
  (and (equal? (length expr) 2) (equal? (length (car expr)) 2) (symbol? (caar expr)) (FormalParams? (second (car expr))) (Expr? (second expr) function)))

(define (FormalParams? expr)
  (cond
    [ (not (list? expr)) false]
    [ (null? expr) true]
    [ (FormalParamList? expr) true]
    [ (not (FormalParamList? expr)) false]))

(define (FormalParamList? expr)
  (if (equal? (length expr) 1)
      (symbol? (car expr))
      (and (symbol? (car expr)) (FormalParamList? (cdr expr)) )))

(define (ApplyF? expr function)
  (and (equal? (length expr) 2) (equal? (length (second expr)) 2) (equal? (first expr) 'apply) (symbol? (car(second expr))) (Args? (second(second expr)) function) (Match? (second expr) function)))

(define (Match? expr function)
  (if (null? function)
      false
      (if (and (equal? (first expr) (first function)) (equal? (length (second expr)) (length (second function)) ))
          true
          (Match? expr (cddr function)))))

      
(define (Args? expr function)
  (cond
    [ (not (list? expr)) false]
    [ (null? expr) true]
    [ (ArgList? expr function) true]
    [ (not (ArgList? expr function)) false]))

(define (ArgList? expr function)
  (if (equal? (length expr) 1)
      (Expr? (car expr) function)
      (and (Expr? (car expr) function) (ArgList? (cdr expr) function) )))

  

;;function to check if the input is a valid OpExpr
;;input: Expr
;;output: #t or #f
;;example: (OpExpr? '(var ((z 3)) (+ z x))): #t
;;example: (OpExpr? '(((z 3)) (+ z x))): #f
(define (OpExpr? expr function)
  (or (ArithExpr? expr function) (CondExpr? expr function) (VarExpr? expr function)));;return true iff it is any of ArithExpr, CondExpr or VarExpr.

;;function to check if the input is a valid ArithExpr
;;input: OpExpr
;;output: #t or #f
;;example: (ArithExpr? '(+ 3 2)): #t
;;example: (ArithExpr? '(/ 2)): #f
(define (ArithExpr? OpExpr function)
  (and (equal? (length OpExpr) 3) (Op? (car OpExpr)) (Expr? (second OpExpr) function) (Expr? (third OpExpr) function)));;return true iff its length is 3 and has form (Op Expr Expr)
;;function to check if the input is a Op
;;input: OpExpr
;;output: #t or #f
;;example: (Op? '+): #t
;;example: (Op? '(*)): #f
(define (Op? OpExpr)
  (or (equal? OpExpr '+) (equal? OpExpr '-) (equal? OpExpr '*) (equal? OpExpr '/)));;return true iff it's any of + - * /
;;function to check if the input is a OpExpr
;;input: OpExpr
;;output: #t or #f
;;example: (CondExpr? (list '(or (gt 3 3) (lt 4 5)) 3 4)): #t
;;example: (CondExpr? (list 'and '(lt 3 4))): #f
(define (CondExpr? OpExpr function)
  (and (equal? (length OpExpr) 3) (CCond? (car OpExpr) function) (Expr? (second OpExpr) function) (Expr? (third OpExpr) function))) ;;return true iff its length is 3 and has form (CCond Expr Expr)
;;function to check if the input is a CCond
;;input: condExpr
;;output: #t or #f
;;example: (CCond? '(or (gt 3 3) (lt 4 5))): #t
;;example: (CCond? (list '(or (gt 3 3) (lt 4 5)) 3)): #f
(define (CCond? condExpr function)
  (if (not (list? condExpr))
      false ;;return false if the input is not a list
      (if (BCond? condExpr function) ;;check if the input is a BCond
          true
          (if (equal? (length condExpr) 2) ;;if it's not a BCond, check length
              (and (equal? (first condExpr) 'not) (CCond? (second condExpr) function)) ;;if its length is 2, return true iff its form is (not CCond) by recursion
              (if (not (equal? (length condExpr) 3)) ;;otherwise
                  false ;; return false if the length is not 2 or 3
                  (or  (and (equal? (first condExpr) 'or) (CCond? (second condExpr) function) (CCond? (third condExpr) function) ) (and (equal? (first condExpr) 'and) (CCond? (second condExpr) function) (CCond? (third condExpr) function))))))))
                  ;; if its length is 3, return true iff its form is (or CCond CCond) | (and CCond CCond) by recursion
       
;;function to check if the input is a BCond
;;input: CCond
;;output: #t or #f
;;example: (BCond? '(gt 3 3)): #t
;;example: (BCond? '(greaterthan 3 4 3)): #f
(define (BCond? CCond function)
   (if (not (equal? (length CCond) 3)) ;; its length has to be 3
       false ;;return false if its length is not 3
       (if (not (or (equal? (first CCond) 'gt) (equal? (first CCond) 'lt) (equal? (first CCond) 'eq) )) ;;check its first element
           false ;;return false iff its first element is not any of gt lt eq
           (and (Expr? (second CCond) function) (Expr? (third CCond) function))))) ;; do recursion and return true ifd its form is  (gt Expr Expr) | (lt Expr Expr) | (eq Expr Expr)
    
;;function to check if the input is a VarExpr
;;input: expr
;;output: #t or #f
;;example: (VarExpr? (list 'var '((x 3) (y 2) (z 6)) '3)): #t
;;example: (VarExpr? (list 'let '((x 3) (y 2) (z 6)) '3)): #f
(define (VarExpr? expr function)
  ;; return true iff its length is 3 and form is  (var VarAssign Expr)
  (or (and (equal? (length expr) 3) (equal? (first expr) 'var) (VarAssign? (second expr) function) (Expr? (third expr) function)) (and (equal? (length expr) 2) (VarAssign? expr function))))
 
;;function to check if the input is a VarAssign
;;input: VarExpr
;;output: #t or #f
;;example: (VarAssign?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssign?  '()): #f
(define (VarAssign? expr function)
  (if (null? expr)
      false ;; return false if the input is null
      (VarAssignSeq? expr function))) ;;otherwise, check if it's a VarAssignSeq
    
;;function to check if the input is a VarAssignSeq
;;input: VarAssign
;;output: #t or #f
;;example: (VarAssignSeq?  '((x 3) (y 2) (z 6))): #t
;;example: (VarAssignSeq?  '(x 3 2)): #f
(define (VarAssignSeq? expr function)
  (if (not (list? expr)) 
      false ;;return false if it's not a list
      (if (null? expr) ;;otherwise
          true ;;return true if it's null
          (if (not (list? (car expr))) ;;if the first element of it is not a list
              (and (equal? (length expr) 2) (not (equal? (car expr) 'apply)) (symbol? (car expr)) (Expr? (second expr) function)) ;;return true iff its length is 2 and form is  (Variable Expr)
              (and (equal? (length (first expr)) 2)(symbol? (first (first expr))) (Expr? (second (first expr)) function) (VarAssignSeq? (cdr expr) function)))))) ;;otherwise, do recursion and return true iff its form is  (Variable Expr) VarAssignSeq


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; eval
;; input: program-expression, environment as list of pairs (variable value)
;; output: '(Cannot Evaluate) or a number

(define (eval expr env)
  (cond
    [ (number? expr) expr ]  ;; number
    [ (symbol? expr) (findvalue expr env) ] ;; sigma(x)

    ;; implementation of the semantics of variable expression
    [ (equal? (car expr) 'var) (evalvarassign (cadr expr) (cadr (cdr expr)) env) ]
 
    ;; same as before with the arithmatic operations: environment is added
    [ (arithop (car expr)) (evalarith (car expr) (cadr expr) (cadr (cdr expr)) env) ]

    ;; for FExpr
    [ (equal? (car expr) 'fun) (eval (third expr) (cons (second expr) env))]

    ;; for ApplyF1
    [ (and (equal? (car expr) 'apply) (not (null? (second (second expr))))) (eval (findMatch (car (second expr)) env) (RenewEnv (second (second expr)) (FuncParams (car (second expr)) env) (cons (findMatchF (car (second expr)) env) env))  )]
    
    ;; for ApplyF2
    [ (and (equal? (car expr) 'apply) (null? (second (second expr)))) (eval (findMatch (car (second expr)) env) (StaticEnv (car (second expr)) (RenewEnv (second (second expr)) (FuncParams (car (second expr)) env)  env))  )]

    ;; ifthenelse function
    [ else  (ifthenelse (evalcond (car expr) env) 
                        (eval (cadr expr) env)
                        (eval (cadr (cdr expr)) env)) ]
    )
  )
(trace eval)
;;findMatch
(define (findMatch fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          (second (car env))
          (findMatch fname (cdr env)))))
;;(trace findMatch)

;;findMatch
(define (findMatchF fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
           (car env)
          (findMatchF fname (cdr env)))))
;;(trace findMatch)

(define (RenewEnv args FP env)
  (if (null? args)
      env
      (cons (list (car FP) (eval (car args) env)) (RenewEnv (cdr args) (cdr FP) env)) 
      ))
;;(trace RenewEnv)

(define (FuncParams fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          (second (caar env))
          (FuncParams fname (cdr env)))))

(define (StaticEnv fname env)
  (if (null? env)
      '(Error)
      (if (and (list? (caar env)) (equal? fname (caaar env)) ) 
          env
          (StaticEnv fname (cdr env)))))
;;(trace StaticEnv)
;; input: variable, environment
;; output: value to which the variable is mapped to in the environment
;;         It can be '(Cannot Evaluate) 
(define (findvalue x env)
  
  (if (equal? (car (car env)) x)
      (cadr (car env))
      (findvalue x (cdr env))))
(trace findvalue)
;; input: list of (variable expression), expr to evaluate, environment
;; output: evaluate expr in some environment
(define (evalvarassign varassigns expr env)
  (if (null? varassigns)  ;; no variable expression pair, 
      (eval expr env)     ;; then just evaluate the expression in the current environment
      ;; else
      ;; recursive call with the suffix of varassigns, with the same expr
      ;; in the environment constructed by cons-ing (variable evaluation of expression)
      ;; to the given environment env.
      (evalvarassign (cdr varassigns)
                     expr
                     (cons (list (car (car varassigns))
                                 (eval (cadr (car varassigns)) env))
                           env))))

;; is op arithmatic operation
(define (arithop op)
  (or (equal? op '+)
      (equal? op '-)
      (equal? op '*)
      (equal? op '\))))

;; input: arithoperator, expr-operand1, expr-operand2, env
;; output: '(Cannot Evaluate) or some number
;; used: myapply 
(define (evalarith op expr1 expr2 env)
 (myapply op (eval expr1 env) (eval  expr2 env)))

;; input: true/false, '(Cannot Evaluate) expression values
;; output: '(Cannot Evaluate) or expression values
;;         expression values can be '(Cannot Evaluate)
(define (ifthenelse condition expr1 expr2)
  (if condition
      expr1
      expr2))

;; input: conditions of the form (gt/lt/eq expr1 expr2), (or/and cond1 cond2), (not cond)
;; output: true/false, '(Cannot Evaluate)
;; used: myapply
(define (evalcond condexpr env)
  (cond
    [ (equal? (car condexpr) 'gt)
      (myapply 'gt (eval (cadr condexpr) env) (eval (cadr (cdr condexpr)) env)) ]
    
    [ (equal? (car condexpr) 'lt)
      (myapply 'lt (eval (cadr condexpr) env) (eval (cadr (cdr condexpr)) env)) ]
    
    [ (equal? (car condexpr) 'and)
      (myapply 'and (evalcond (cadr condexpr) env)
               (evalcond (cadr (cdr condexpr)) env)) ]

    [ (equal? (car condexpr) 'or)
      (myapply 'or (evalcond (cadr condexpr) env)
               (evalcond (cadr (cdr condexpr)) env)) ]

    [ (equal? (car condexpr) 'not)
      (myapply 'not (evalcond (cadr condexpr) env)
               false) ] ;; dummy
    ))


;; input: some operator, arithmatic or conditional
;;        operand-values for the operator
;; output: '(Cannot Evaluate) or number or boolean 
(define (myapply op val1 val2)
  (cond
    [ (equal? op '+) (+ val1 val2) ]
    [ (equal? op '-) (- val1 val2) ]
    [ (equal? op '*) (* val1 val2) ]
    [ (equal? op 'gt) (> val1 val2) ]
    [ (equal? op 'lt) (< val1 val2) ]
    [ (equal? op 'eq) (equal? val1 val2) ]
    [ (equal? op 'and) (and val1 val2) ]
    [ (equal? op 'or) (or val1 val2) ]
    [ (equal? op 'not) (not val1) ]))